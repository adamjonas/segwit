# Some Responses to the Discussion Questions

2. As long as the condition of a valid spend is solely defined by the stack state at the end of the script run, the input script will always remain malleable, as their are arbitrarily many input scripts which result in the same stack state. Segwit's solution is to move the input script data into the transaction witness field, where it remains malleable, but does not affect TXID. (James)
4. Non-witness nodes never receive any witness data or witness blocks (BIP144), and only validate the spending of [0 20/32b-hash] witness script (no witness data is available and is not evaluated). The correctness of a witness spend therefore differs between old/new nodes. If the strong-chain is a witness chain, it is safe to assume old nodes will follow this chain, and the correctness of witness transactions is implied by POW for these older nodes. If the strong-chain is not a witness chain, new nodes will fork off (weak-chain), but old nodes will continue to follow it. It is not safe to conduct witness transactions on this non-witness strong-chain. This is why miner-support for SegWit is relevant during activation.
5. TX version field for example is checked by `op_checksequenceverify`, a script op_code. The witness version is not checked by a script operator, but pushed onto the stack and evaluated at the end of the script run, when the witness script pattern is detected. I suppose it would entirely be possible to encode the witness version in the version field as well.
9. Explanation by [Sipa](https://youtu.be/NOYNZB5BCHM?t=1625)
